<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="">
  <meta content="">
  <meta content="">
  <meta content="">
  <meta content="">
  <meta content="">
  <meta content="">
  <meta content="">
  <meta content="">
  <meta content="">
  <meta http-equiv="content-type" content="">
  <title>Migrating from Axis 1.x</title>
</head>

<body lang="en">
<h1>Migrating from Axis 1.x to Axis 2</h1>

<h2>Compatibility</h2>

<p>Axis1.x and Axis2 have been evolved from different architectures.</p>

<p><strong>Speed</strong> - Axis2 is based on StAX API, which gives greater
speed than SAX event based parsing that has been used in Axis1.x.</p>

<p><strong>Stability</strong> - Axis2 has fixed phases and for extensions an
area of user defined phases. This allows far more stability and flexibility
than Axis1.x.</p>

<p><strong>Transport framework</strong> - Simple abstraction in the designing of
transports (i.e., senders and listeners for SOAP over various protocols such
as SMTP, etc), allows far more flexibility and the core of the engine is
completely transport-independent.</p>

<p><strong>WSDL support</strong> - Axis2 supports version 1.1 and 2.0, which
allows creating stubs and skeletons, to manipulate the web services arena.</p>

<p><strong>Component - oriented architecture</strong> - This is merely
through archives (.mar and .aar) . Easily reusable components such as
handlers, modules allow patterns processing for your applications, or to
distribution to partners. Axis2 is more concerned on the "Module" concept rather the
"Handler" concept. Modules contain handlers that have been ordered through the
phase rules. These are ordered to specific service(s).</p>

<h2>Getting started</h2>

<p>Lets look at a simple example of echoing at client API.</p>

<p><b>Axis 1.x</b></p>
<pre>import ...
public class TestClient {
        public static void main(String [] args) {
                try {
                        String endpoint = ... ;
                        Service axisService = new Service();
                        Call call = (Call) axisService.createCall();
                        call.setTargetEndpointAddress( new java.net.URL(endpoint) );
                        call.setOperationName(new QName("http://soapinterop.org/", echoString"));
                        String ret = (String) call.invoke( new Object[] { "Hello!" } );
                        System.out.println("Sent 'Hello!', got '" + ret + "'");
                } catch (Exception e) {
                        System.err.println(e.toString());
                }
        }
}</pre>

<p><b>Axis 2</b></p>
<pre>import ...
public class EchoBlockingClient {
        private static EndpointReference targetEPR = new EndpointReference(
        AddressingConstants.WSA_TO,
                                "http://127.0.0.1:8080/axis2/services/MyService");
        public static void main(String[] args) {
                try {
                        OMElement payload = ClientUtil.getEchoOMElement();
                        Options options = new Options();
                        ServiceClient client = new ServiceClient();
                        options.setTo(targetEPR);
                        //Blocking invocation
                        OMElement result = client.sendReceive(payload);
                        ...
                } catch (AxisFault axisFault) {
                        axisFault.printStackTrace();
                } catch (XMLStreamException e) {
                        e.printStackTrace();
                }
        }
}</pre>

<p>It has been clearly depicted that the invocation in Axis2 is dealt with SOAP
body element itself. Here the invocation is synchronous but Axis2 can handle
asynchronous invocations as well. The "payload" variable above contains the SOAP body element
which should go in the soap envelope.</p>

<p>Once the service is called through the stub in Axis2, "payload" is according
to the data binding framework that will be used. So the extra work of
"payload" will be vanished.</p>

<p>Apart from synchronous invocation, Axis2 supports asynchronous invocation
through sendReceiveNonblocking(). Synchronous/Asynchronous invocations can
handle both single/double HTTP connections.</p>

<p>With this advanced architecture, Axis2 is capable of handling megabytes of
requests and responses, which is far from what Axis1.x was capable of.</p>

<h2>Custom deployment of services, handlers and modules</h2>

<p>In Axis 1.x, the deployment of services was via WSDD, which in my opinion was
highly cumbersome. Service deployment in Axis2 is straight forward and
dynamic. Dynamic behavior is from the "Administrator" facility given by the
development in the server side. It's just a matter of creating the .aar file, and
deploying it. More detail regarding this is given in the Axis2 user guide.</p>

<p>Axis2 is far from the "Handler concept" and is more into the "Module concept". 
Abstractly speaking, the module concept is a collection of handlers with rules of
governing which modules are created as .mar files. It has module.xml, which is the
brain behind manipulating the handlers.</p>

<p>When a service is called through a handler, it is just a matter of giving a
reference to the module that includes the handler in the services.xml (using
&lt;module ref="foo/&gt;").</p>

<p>Services are hot deployable in Axis2, but modules are not. This is one
feature which is unique to Axis2.</p>

<p>Lets take a detailed look at what it takes to migrate the Axis 1.x handlers to the
Axis 2 modules via the "SOAP Monitor". The SOAP monitor is really a combination of three
components: An applet which displays responses / requests, a servlet which
binds to a default port of 5001 and connects to the applet, and a handler
chain used to intercept the soap messages. Here we'll focus on the
handler.</p>

<p><b>Axis 1.x required two WSDD's to use the SOAP Monitor. First, the SOAP
Monitor Handler itself:</b></p>
<pre>&lt;deployment xmlns="http://xml.apache.org/axis/wsdd/"
    xmlns:java="http://xml.apache.org/axis/wsdd/providers/java"&gt;
    
  &lt;handler name="soapmonitor" 
      type="java:org.apache.axis.handlers.SOAPMonitorHandler"&gt;
    &lt;parameter name="wsdlURL" 
      value="/wzs/SOAPMonitorService-impl.wsdl"/&gt;
    &lt;parameter name="namespace" 
      value="http://tempuri.org/wsdl/2001/12/SOAPMonitorService-impl.wsdl"/&gt;
    &lt;parameter name="serviceName" value="SOAPMonitorService"/&gt;
    &lt;parameter name="portName" value="Demo"/&gt;
  &lt;/handler&gt;

  &lt;service name="SOAPMonitorService" provider="java:RPC"&gt;
    &lt;parameter name="allowedMethods" value="publishMessage"/&gt;
    &lt;parameter name="className" 
      value="org.apache.axis.monitor.SOAPMonitorService"/&gt;
    &lt;parameter name="scope" value="Application"/&gt;
  &lt;/service&gt;
&lt;/deployment&gt;</pre>

<p><b>Axis 1.x requires a reference to the handler in the user's WSDD that
defines their Web Service:</b></p>
<pre>&lt;deployment name="example" xmlns="http://xml.apache.org/axis/wsdd/" 
    xmlns:java="http://xml.apache.org/axis/wsdd/providers/java"&gt;
  
  &lt;service name="urn:myService" provider="java:RPC"&gt;
    &lt;parameter name="className" value="org.MyService"/&gt;
    &lt;parameter name="allowedMethods" value="*"/&gt;

    &lt;requestFlow&gt;
      &lt;handler type="soapmonitor"/&gt;
    &lt;/requestFlow&gt;
    &lt;responseFlow&gt;
      &lt;handler type="soapmonitor"/&gt;
    &lt;/responseFlow&gt;

  &lt;/service&gt;
&lt;/deployment&gt;</pre>

<p><b>Axis 2 requires a module.xml, placed inside a jar with a .mar extension
under WEB-INF/modules, to define a Handler:</b></p>
<pre>&lt;module name="soapmonitor" class="org.apache.axis2.handlers.soapmonitor.SOAPMonitorModule"&gt;
    &lt;inflow&gt;
        &lt;handler name="InFlowSOAPMonitorHandler" class="org.apache.axis2.handlers.soapmonitor.SOAPMonitorHandler"&gt;
            &lt;order phase="soapmonitorPhase"/&gt;
        &lt;/handler&gt;
    &lt;/inflow&gt;

    &lt;outflow&gt;
        &lt;handler name="OutFlowSOAPMonitorHandler" class="org.apache.axis2.handlers.soapmonitor.SOAPMonitorHandler"&gt;
            &lt;order phase="soapmonitorPhase"/&gt;
        &lt;/handler&gt;
    &lt;/outflow&gt;

    &lt;Outfaultflow&gt;
        &lt;handler name="FaultOutFlowSOAPMonitorHandler" class="org.apache.axis2.handlers.soapmonitor.SOAPMonitorHandler"&gt;
            &lt;order phase="soapmonitorPhase"/&gt;
        &lt;/handler&gt;
    &lt;/Outfaultflow&gt;

    &lt;INfaultflow&gt;
        &lt;handler name="FaultInFlowSOAPMonitorHandler" class="org.apache.axis2.handlers.soapmonitor.SOAPMonitorHandler"&gt;
            &lt;order phase="soapmonitorPhase"/&gt;
        &lt;/handler&gt;
    &lt;/INfaultflow&gt;
&lt;/module&gt;</pre>

<p>The SOAPMonitorModule referenced above simply implements
org.apache.axis2.modules.Module and is used for any additional tasks needed
to initialize the module and shutdown the module. In this case nothing is
needed and the implemented interface methods have blank bodies. Furthermore,
the 'soapmonitorPhase' will be used later below in the axis2.xml .</p>

<p><b>Axis 1.x the SOAPMonitorHandler has the class signature as:</b></p>
<pre>public class SOAPMonitorHandler extends BasicHandler</pre>

<p><b>Axis 2 the SOAPMonitorHandler has the class signature as:</b></p>
<pre>public class SOAPMonitorHandler extends AbstractHandler </pre>

<p><b>In axis2, you need to reference the module that contains the handler
chain that you want to use inside your services.xml:</b></p>
<pre>&lt;service name="ExampleService"&gt;
    &lt;module ref="soapmonitor"/&gt;
    &lt;description&gt;
       This service has the SOAP Monitor wired in 
    &lt;/description&gt;
    &lt;parameter name="ServiceClass" locked="false"&gt;org.ExampleService&lt;/parameter&gt;
    &lt;operation name="myExecute"&gt;
        &lt;messageReceiver class="org.apache.axis2.receivers.RawXMLINOutMessageReceiver"/&gt;
    &lt;/operation&gt;
&lt;/service&gt;</pre>

<p><b>Finally, axis2 requires you to make some changes to axis2.xml. Start by
adding a global module:</b></p>
<pre>    &lt;module ref="soapmonitor"/&gt;</pre>

<p><b>Then define your phase orders for 'soapmonitorPhase' referenced in the
module.xml :</b></p>
<pre>    &lt;phaseOrder type="inflow"&gt;
        &lt;!--  System pre defined phases       --&gt;
        &lt;phase name="TransportIn"/&gt;
        &lt;phase name="PreDispatch"/&gt;
        &lt;phase name="Dispatch" class="org.apache.axis2.engine.DispatchPhase"&gt;
            &lt;handler name="AddressingBasedDispatcher"
                     class="org.apache.axis2.engine.AddressingBasedDispatcher"&gt;
                &lt;order phase="Dispatch"/&gt;
            &lt;/handler&gt;

            &lt;handler name="RequestURIBasedDispatcher"
                     class="org.apache.axis2.engine.RequestURIBasedDispatcher"&gt;
                &lt;order phase="Dispatch"/&gt;
            &lt;/handler&gt;

            &lt;handler name="SOAPActionBasedDispatcher"
                     class="org.apache.axis2.engine.SOAPActionBasedDispatcher"&gt;
                &lt;order phase="Dispatch"/&gt;
            &lt;/handler&gt;

            &lt;handler name="SOAPMessageBodyBasedDispatcher"
                     class="org.apache.axis2.engine.SOAPMessageBodyBasedDispatcher"&gt;
                &lt;order phase="Dispatch"/&gt;
            &lt;/handler&gt;
            &lt;handler name="InstanceDispatcher"
                     class="org.apache.axis2.engine.InstanceDispatcher"&gt;
                &lt;order phase="PostDispatch"/&gt;
            &lt;/handler&gt;
        &lt;/phase&gt;
        &lt;!--  System pre defined phases       --&gt;
        &lt;!--   After Postdispatch phase module author or or service author can add any phase he want      --&gt;
        &lt;phase name="userphase1"/&gt;
        &lt;phase name="soapmonitorPhase"/&gt;
    &lt;/phaseOrder&gt;
    &lt;phaseOrder type="outflow"&gt;
        &lt;!--      user can add his own phases to this area  --&gt;
        &lt;phase name="userphase1"/&gt;
        &lt;phase name="soapmonitorPhase"/&gt;
        &lt;!--system predefined phase--&gt;
        &lt;!--these phase will run irrespective of the service--&gt;
        &lt;phase name="PolicyDetermination"/&gt;
        &lt;phase name="MessageOut"/&gt;
    &lt;/phaseOrder&gt;
    &lt;phaseOrder type="INfaultflow"&gt;
        &lt;!--      user can add his own phases to this area  --&gt;
        &lt;phase name="userphase1"/&gt;
        &lt;phase name="soapmonitorPhase"/&gt;
    &lt;/phaseOrder&gt;
    &lt;phaseOrder type="Outfaultflow"&gt;
        &lt;!--      user can add his own phases to this area  --&gt;
        &lt;phase name="userphase1"/&gt;
        &lt;phase name="soapmonitorPhase"/&gt;
        &lt;phase name="PolicyDetermination"/&gt;
        &lt;phase name="MessageOut"/&gt;
    &lt;/phaseOrder&gt;</pre>

<p>See the user guide for more info on axis2 modules.</p>

<h2>Transports for HTTP Connection</h2>

<p>Axis2 comes with two  CommonsHTTPTransportSender which is based on
commons-httpclient.</p>

<p>It should be noted that axis2.xml should be configured to call the commons
transports, with the statement,</p>
<pre>...
&lt;transportSender name="http" class="org.apache.axis2.transport.http.CommonsHTTPTransportSender"&gt; 
   &lt;parameter name="PROTOCOL" locked="false"&gt;HTTP/1.1&lt;/parameter&gt; 
   &lt;parameter name="Transfer-Encoding" locked="false"&gt;chunked&lt;/parameter&gt;
&lt;/transportSender&gt;
...</pre>

<h2>Data Binding Support</h2>

<p>ADB is used to provide data binding support. In Axis2, xml is manipulated
via AXIOM, which is based on the StAX API. XML gives full schema support. Thus,
serialization and de-serialization of XML is handled in Axis2 via the xml-data
binding framework.</p>

<h2>Best Usage</h2>

<p>Axis1.x and Axis2 have different ways of seeing the SOAP stack. So the best
way to migrate is to follow the User guide and the Architecture
guide of Axis2 properly. Axis2 is very much straight forward and friendly to use than it's successor.</p>
</body>
</html>
