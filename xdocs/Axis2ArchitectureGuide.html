<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=windows-1252">
	<TITLE>Axis2 Architecture Guide</TITLE>
	<META NAME="GENERATOR" CONTENT="OpenOffice.org 1.1.4  (Win32)">
	<META NAME="CREATED" CONTENT="20050916;22455288">
	<META NAME="CHANGEDBY" CONTENT="Chamikara Jayalath">
	<META NAME="CHANGED" CONTENT="20050918;22325179">
</HEAD>
<BODY LANG="en-US" DIR="LTR">
<H1>Axis2 Architecture Guide</H1>
<H2>Contents</H2>
<UL>
	<LI><P><A HREF="#bmBP">The Big Picture</A></P>
	<LI><P><A HREF="#bmInfoMod">Information Model</A></P>
	<LI><P><A HREF="#bmXML">XML Processing Model</A></P>
	<LI><P><A HREF="#bmSOAPPM">SOAP Processing Model</A></P>
	<LI><P><A HREF="#bmDeployment">Deployment</A></P>
	<LI><P><A HREF="#bmWSDL">WSDL and code generation</A></P>
	<LI><P><A HREF="#bmDB">Data Binding</A></P>
	<LI><P><A HREF="#bmClientAPI">Client API</A></P>
	<LI><P><A HREF="#bmTransports">Transports</A></P>
</UL>
<P><BR><BR>
</P>
<H2><A NAME="bmBP"></A>The Big Picture</H2>
<P>Any architecture is a result of what that architecture should
yield, the success of an architecture should be evaluated bases on
the requirements the architecture should meet. Let us start our
journey in to Axis2 looking at the requirements that are expected
from Axis2.</P>
<H3>Requirement of Axis2</H3>
<P>In the SOAP terminology, a participant who is taking part in a Web
Service interaction is known as a SOAP Node. Delivery of a single
SOAP Message is defined based on two participants, SOAP Sender and
SOAP Receiver. Each SOAP Message is sent by SOAP Sender and received
by SOAP Receiver, and single SOAP delivery is the most basic unit
that builds the Web Service interactions.</P>
<P>Each SOAP Node may be written in specific programming language,
may it be Java, C++, .NET or Perl, the Web Services allow them to
inter operate. This is possible because at the wire each Web Service
interaction is done via SOAP, which is common to every SOAP Node. 
</P>
<P><IMG SRC="images/archi-guide/soap.gif" NAME="Graphic1" ALIGN=BOTTOM WIDTH=691 HEIGHT=319 BORDER=0>
</P>
<P>Web Service middleware handles the complexity SOAP messaging and
let the users to work with the programming language they are
accustomed to. Axis2 allows the java users to invoke the Web Services
using java representations and handles the SOAP messaging behind the
curtain. 
</P>
<P>Axis2 handles SOAP processing, along with numerous other
functionalities that make the life of the Web Service developer
convenient. Following are the identified requirements: 
</P>
<OL>
	<LI><P STYLE="margin-bottom: 0in">Provide a framework to process the
	SOAP messages, the framework should be extensible and the users
	should be able to extend the SOAP processing per service or
	operation basis. Furthermore it should be able to model different
	Message Exchange Patterns using the processing framework. 
	</P>
	<LI><P STYLE="margin-bottom: 0in">Ability to deploy the Web Services
	(with or without WSDL) 
	</P>
	<LI><P STYLE="margin-bottom: 0in">Provide a Client API that can be
	used to invoke Web Services, the API should supports both the
	Synchronous and Asynchronous programming models. 
	</P>
	<LI><P STYLE="margin-bottom: 0in">Ability to configure Axis2 and
	it's components via the deployment 
	</P>
	<LI><P>Ability to send and receive SOAP messages with different
	transports</P>
</OL>
<P>Apart from the above functionalities, performance, both in the
terms of memory and speed, is a major consideration for Axis2. Axis2
Core Architecture is built on three specifications, WSDL, SOAP and
WS-Addressing. Other specifications like JAX-RPC and SAAJ are layered
on top of the Core Architecture. The WS-Policy might join the core
specifications in the near future. 
</P>
<H3>Axis2, the Architecture</H3>
<P>Now having look at the requirements of the Axis2 we can direct our
attention to the Architecture. 
</P>
<P>Axis2 architecture lay out few Principals to preserve the
uniformity of the architecture, they are as follows. 
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0in">Axis2 Architecture separates the
	logic and the states, the code that process the logic is usually
	stateless. This allows the code to be executed freely by parallel
	threads. 
	</P>
	<LI><P>All the information is kept in a one Information model, this
	allows the system to be stored and resumed 
	</P>
</UL>
<P>Axis2 architecture is modular, the architecture broke the Axis2 in
to Seven modules. 
</P>
<OL>
	<LI><P STYLE="margin-bottom: 0in">Information Model 
	</P>
	<LI><P STYLE="margin-bottom: 0in">XML processing Model 
	</P>
	<LI><P STYLE="margin-bottom: 0in">SOAP Processing Model 
	</P>
	<LI><P STYLE="margin-bottom: 0in">Deployment 
	</P>
	<LI><P STYLE="margin-bottom: 0in">WSDL and Code Generation 
	</P>
	<LI><P STYLE="margin-bottom: 0in">Client API 
	</P>
	<LI><P>Transports 
	</P>
</OL>
<P><IMG SRC="images/archi-guide/all.png" NAME="Graphic2" ALIGN=BOTTOM WIDTH=426 HEIGHT=189 BORDER=0>
</P>
<P>Let us look in to the rationale for each Module, and what each
does? 
</P>
<P>Axis2 defines a model to handle the information and all the states
are kept in this model. The model has a hierarchy for the information
and the system manages the life cycle of the objects in this
hierarchy. 
</P>
<P>Handling the SOAP Message is the most important and the most
complex task, the efficiency of this is the single most important
factor that decides the performance. It make sense to delegate this
task to a separate module, and that module, AXIOM provide a simple
API for SOAP and XML info-set and while hiding the complexities of
the efficient XML processing with in the implementation. 
</P>
<P>SOAP Processing Model controls the execution of the processing,
the Model defines different phases the execution would walk though,
and the user can extend the Processing Model at some specific places.
</P>
<P>Axis2 define a transport framework that enables user to use
different transports, the transports match in to the specific places
in the SOAP processing model. The implementation provide few common
transports and user may write new ones if he wishes. 
</P>
<P>Axis2 deployment model allows the user to deploy services,
configure the transports, extend the SOAP Processing model per system
basis, per service basis, and per operation basis. 
</P>
<P>Finally Axis2 provides a code generation tool that will generate
server side and client side code along a test case. The generated
code would simplify the service deployment and the service
invocation. This would make the Axis2 easier to use. 
</P>
<H2><A NAME="bmInfoMod"></A>Information Model</H2>
<P>Information Model has two main hierarchies, the Contexts and
Descriptions. 
</P>
<P><IMG SRC="images/archi-guide/contexts.png" NAME="Graphic3" ALIGN=BOTTOM WIDTH=400 HEIGHT=443 BORDER=0>
</P>
<P>This uses UML notations ( A ----&lt;&gt; B means B has 1 or more
objects of A. A------&gt;B means the given relationship holds between
A and B.)</P>
<P>The two hierarchies are connected as shown in the above figure.
The Description hierarchy represents data that exists throughout the
lifetime of Axis2. Examples for such data would be deployed Web
Services, operations, etc. On the other hand, the context hierarchy
holds more dynamic information about things that has more than one
instances (e.g.Message Context). 
</P>
<P>These two hierarchies created a model that provides the ability to
search for key value pairs, when the values are searched at a given
level, they are searched while moving up in the level until a match
is found. In the resulting model the lower levels overrides the
values in the upper levels. For and example when a value is looked up
at the Message Context and it is not found, it would be looked up at
the Operation Context etc, up the hierarchy. The Search is first done
up the hierarchy, and if starting point is a Context then it is
search in the Description hierarchy as well.</P>
<P>This allows user to declare and override values, and result in
very flexible configuration model. The flexibility could be the
Achilles heel for the system, as the search, specially for something
that does not exist is expensive, yet in the final analysis
developers believe that the flexibility would serve better in this
instants and opt for the flexibility. 
</P>
<TABLE WIDTH=955 BORDER=1 CELLPADDING=2 CELLSPACING=3>
	<COL WIDTH=112>
	<COL WIDTH=371>
	<COL WIDTH=103>
	<COL WIDTH=336>
	<TR>
		<TD WIDTH=112>
			<P>Configuration Context</P>
		</TD>
		<TD WIDTH=371>
			<P>Holds the current state of execution. A deep copy of this would
			essentially make a copy of Axis2.</P>
		</TD>
		<TD WIDTH=103>
			<P>Axis Configuration 
			</P>
		</TD>
		<TD WIDTH=336>
			<P>Holds all global configurations. Transports, global modules,
			parameters and Services. 
			</P>
		</TD>
	</TR>
	<TR>
		<TD WIDTH=112>
			<P>Service Group Context</P>
		</TD>
		<TD WIDTH=371>
			<P>Holds information about a perticular usage of the respective
			service group. The life of a Service Group Context start when a
			user start to interact with a service that belong to this service
			group. This can be used to share information between service
			usages in a single interaction, for services that belong to the
			same group.</P>
		</TD>
		<TD WIDTH=103>
			<P>ServiceGroup Description</P>
		</TD>
		<TD WIDTH=336>
			<P>Holds deployment time information about a perticular service
			group.</P>
		</TD>
	</TR>
	<TR>
		<TD WIDTH=112>
			<P>Service Context</P>
		</TD>
		<TD WIDTH=371>
			<P>This context is avaliable throughout a usage of the respective
			service. This can be used to share information between several
			MAPs that belong to the same service, within a single interaction.</P>
		</TD>
		<TD WIDTH=103>
			<P>Service Description</P>
		</TD>
		<TD WIDTH=336>
			<P>Hold the Operations and the service level configurations</P>
		</TD>
	</TR>
	<TR>
		<TD WIDTH=112>
			<P>Operation Context 
			</P>
		</TD>
		<TD WIDTH=371>
			<P>Holds the information about the current MEP instance, maintain
			the Messages in the current MEP etc.</P>
		</TD>
		<TD WIDTH=103>
			<P>Operation Description</P>
		</TD>
		<TD WIDTH=336>
			<P>Holds the operation level configurations</P>
		</TD>
	</TR>
	<TR>
		<TD WIDTH=112>
			<P><A NAME="messageContext"></A>Message Context</P>
		</TD>
		<TD WIDTH=371>
			<P>Holds all the information about the Message currently being
			executed. 
			</P>
		</TD>
		<TD WIDTH=103>
			<P>Message Description</P>
		</TD>
		<TD WIDTH=336>
			<P>Do not hold any information as yet, but can be used as future
			extension point.</P>
		</TD>
	</TR>
</TABLE>
<P><BR><BR>
</P>
<P>All context classes implement readObject, writeObject methods that
allows to serialize and deserialize them correctly. Serializing the
current Configuration Context object would assentially serialize the
whole contex thierarchy. To restore it, the user has to fist perform
the deserialization of the ConfigurationContext object. He can
restore the description hierarchy by calling the init
(axisConfiguration) method of the deserialized ConfigurationContext
object.</P>
<H2><A NAME="bmXML"></A>XML Processing Model</H2>
<P>Please refer to the <A HREF="OMTutorial.html">OM Tutorial</A></P>
<H2><A NAME="bmSOAPPM"></A>SOAP Processing Model</H2>
<P><IMG SRC="images/archi-guide/soap-processing.gif" NAME="Graphic4" ALIGN=BOTTOM WIDTH=755 HEIGHT=348 BORDER=0></P>
<P>The architecture identified two basic actions a SOAP processor
should perform, sending and receiving SOAP messages. The architecture
provides two Pipes (also named 'Flows'), to perform these two basic
actions. Axis Engine or the driver of Axis2 defines two methods
send() and receive() to implement these two Pipes. The two pipes are
named <I>In Pipe</I> and <I>Out Pipe</I>, the complex Message
Exchange Patterns are constructed by combining these two pipes.</P>
<P>Extensibility of the SOAP processing model is provided through the
Handlers. When a SOAP message is being processed the Handlers that
are registered would be executed. The Handlers can be registered in
global, service, or operation scopes and the final handler chain is
calculated combining the Handlers from all the scopes.</P>
<P>The Handlers act as interceptors and they process the parts of the
SOAP message and provide add on services. Usually Handlers work on
the SOAP Headers yet they may access or change the SOAP Body as well.</P>
<P>When a SOAP message is send from the Client API, a <I>Out Pipe</I>
would begin, the <I>Out Pipe</I> invokes the Handlers and ends with a
Transport Sender that sends the SOAP message to the target endpoint.
The SOAP message is received by a Transport Receiver at the target
endpoint, which reads the SOAP message and starts the <I>In Pipe</I>.
The In Pipe consists of Handlers and ends with a <A HREF="#mr">Message
Receiver</A>, which consumes the SOAP message.</P>
<P>Above explained processing happens for each and every SOAP message
exchanged. Processing that follows may decide to give birth for the
other SOAP messages, in which case the more complex patterns emerge.
But Axis2 always view the SOAP message in terms of processing of a
single message where as the combination of the messages are layered
on top of that basic framework. 
</P>
<P>The two pipes does not differentiate between the Server and the
Client, the SOAP Processing Model handles the complexity and provides
two abstract pipes to the user. Each pipe is a set of Handlers, the
different areas of the pipes are given names, and according to the
Axis2 slang those are named 'Phases'. A Handler always runs inside a
Phase, and the Phase provides a mechanism to specify the ordering of
Handlers. Both Pipes has built in Phases, and both define the areas
for 'User Phases' which can be defined by the user.</P>
<P>Following figure shows the two pipes with their pre-defined
Phases, the user defined Phases would be fit in to the User Phases.</P>
<P><IMG SRC="images/archi-guide/phases.png" NAME="Graphic5" ALIGN=BOTTOM WIDTH=525 HEIGHT=226 BORDER=0>
</P>
<H3>Axis2 Default Processing Model</H3>
<P>Axis2 has the, some inbuilt Handlers that run in inbuilt Phases
and they create the default configuration for the Axis2, we will be
looking more in to how to extend the default processing Model in the
next section. 
</P>
<P>There are four special handlers defined in Axis2.</P>
<OL>
	<LI><P STYLE="margin-bottom: 0in">Dispatchers - Find the Service the
	SOAP message is directed to, always run on the In-Pipe and inside
	the Dispatch Phase. There is a inbuilt Dispatcher, that run in any
	case and user may override it by placing the dispatchers before the
	inbuilt Dispatcher. 
	</P>
	<LI><P STYLE="margin-bottom: 0in"><A NAME="mr"></A>Message Receiver
	- Consume the SOAP Message and run on the Message Processing Phase
	in the inflow 
	</P>
	<LI><P>Transport Sender - Send the SOAP message to the SOAP endpoint
	the message is destined to. Always runs on the 
	</P>
</OL>
<H3>Processing an Incoming SOAP Message</H3>
<P>Incoming SOAP Message is always received by a Transport Receiver
waiting for the SOAP Messages, once the SOAP Message is arrived the
transport Headers are parsed and a <A HREF="#messageContext">Message
Context</A> is created for the incoming SOAP Message. The the <I>In
Pipe</I> is executed with the Message Context. Let us see what would
happen at the each Phase of the execution, this process my happen in
either in the server or the Client, there is a special case of using
the two way transport where the first four phases in the In-Phase
most likely to do nothing.</P>
<OL>
	<LI><P STYLE="margin-bottom: 0in">Transport Phase - The Handlers in
	the transport Phase are taken from the transport configuration
	associated, they are executed according to the Phase rules. 
	</P>
	<LI><P STYLE="margin-bottom: 0in">Pre-Dispatch Phase- The Handlers
	that goes there must be engaged globally (for all services) as the
	Service does not known at this point. The best example for them
	would be, Addressing Handlers and may be security Handlers if the
	Addressing Headers are encrypted. 
	</P>
	<LI><P STYLE="margin-bottom: 0in">Dispatch Phase - The Dispatchers
	are run in this Phases and find the Service if the service is not
	found already. 
	</P>
	<LI><P STYLE="margin-bottom: 0in">Post-Dispatch Phase - This phase
	check weather the service is found, if the service has not found by
	this point the execution will halt and send a &quot;service not
	found error&quot;. Policy Determination Phase - This Phase does
	nothing for the time being, this is placed for the implementing the
	Policy 
	</P>
	<LI><P STYLE="margin-bottom: 0in">User Defined Phases - User defined
	Phases are executed here. 
	</P>
	<LI><P STYLE="margin-bottom: 0in">Message Validation Phase - Once
	the user level execution is taken place, this Phase will validates
	has the SOAP Message Processing has taken place correctly. For an
	example the must understand processing would happen here. 
	</P>
	<LI><P>Message Processing Phase - The Business logic of the SOAP
	message, executed here, the a <A HREF="#mr">Message Receiver</A> is
	registered with a each Operation. The Message receiver associated
	with the each operation would be executed as the last Handler of
	this Phase. 
	</P>
</OL>
<P>There may be other handlers in the any of the these Phases, users
may employ custom Handlers to override the mechanics in the each of
these Phases. If there is a response message, that would be initiated
by the <A HREF="#mr">Message Receiver</A>, yet the architecture is
not aware of the response message and merely invoke the <A HREF="#mr">Message
Receiver</A>.</P>
<H3>Processing of the Outgoing Message</H3>
<P>Out pipe is simpler because the Service and the Operation to
dispatch is known by the time the pipe is executed. The Out pipe may
be initiated by the <A HREF="#mr">Message Receiver</A> or the Client
API implementation. 
</P>
<OL>
	<LI><P STYLE="margin-bottom: 0in">Message Initialize Phase - Fist
	Phase of the out pipe, this serves as the placeholder for the custom
	Handlers 
	</P>
	<LI><P STYLE="margin-bottom: 0in">Policy Determination Phase - Just
	like in the in-pipe this is not implemented and suppose to serve as
	a extension point 
	</P>
	<LI><P STYLE="margin-bottom: 0in">User Phases - This executes
	Handlers in user define Phases 
	</P>
	<LI><P>Transports Phase - Execute any transport Handlers taken from
	the associated transport configuration and the last handler would be
	a transport Sender which would send the SOAP message to the target
	end point 
	</P>
</OL>
<H3>Extending SOAP Processing Model</H3>
<P>We discussed the default processing model of the Axis2, ability to
extend the model has been the whole point of spending the energy on
the SOAP processing model. We shall discuss the extension mechanism
for the SOAP processing model now.</P>
<P>Idea behind making each step of the SOAP processing in terms of
Handlers (inbuilt ones we discuss earlier) and placing them in the
Phases is to allow Handlers to be placed between those Handlers and
to override or affect the default mechanics. There are two ways the
to extend the SOAP Processing Model.</P>
<H4>Extending the SOAP Processing Model with Handlers</H4>
<P>The Handlers can specify the Phase they need to be run, further
more they can specify the there location inside a phase via the
following information.</P>
<OL>
	<LI><P STYLE="margin-bottom: 0in">Handler should run as the first in
	the phases 
	</P>
	<LI><P STYLE="margin-bottom: 0in">Handler should run as the last in
	the Phases 
	</P>
	<LI><P STYLE="margin-bottom: 0in">Handler should run before a given
	Handlers 
	</P>
	<LI><P>Handler should run after a Given Handler 
	</P>
</OL>
<H4>Extending the SOAP Processing Model with Modules</H4>
<P>SOAP processing Model defines a logical entity called a module
that encapsulates two entities, Handlers and Web Service Operations.
The Handlers will act in the same way as explained in the first
method.</P>
<P>Apart from the extension mechanism based on the Handlers, the WS-*
specifications suggest a requirement for add new Operations using
modules. For an example once a user add a Reliable Messaging
capability to a Service, the &quot;Create Sequence&quot; operation
needs to be available to the service end point. This can be
implemented by letting the Modules define the operations and once the
module is engaged to a service the operations will be added to that
service. 
</P>
<P>A service, operations or the system may engage a module, once the
module is engaged the handlers and the operations defined in the
module are added to the entity that engages them. Modules can not be
added while the Axis2 is running but rater it ll be available once
the system is restarted.</P>
<H2><A NAME="bmDeployment"></A>Deployment</H2>
<P>There deployment Model provides a concrete mechanism to configure
Axis2. Deployment Model has four entities that provide the
configuration. 
</P>
<H3>The <EM>axis2.xml</EM> file 
</H3>
<P>This file holds the global configuration for the client and
server, and provide following information.</P>
<OL>
	<LI><P STYLE="margin-bottom: 0in">The global parameters 
	</P>
	<LI><P STYLE="margin-bottom: 0in">Registered transports in and
	transport outs 
	</P>
	<LI><P STYLE="margin-bottom: 0in">User defined Phase names 
	</P>
	<LI><P STYLE="margin-bottom: 0in">Modules that are engaged globally 
	</P>
	<LI><P>Globally defines <A HREF="#mr">Message Receiver</A>s 
	</P>
</OL>
<H3>Service Archive</H3>
<P>Service archive must have a <EM>META-INF/services.xml</EM> file
and may contain the dependent classes. the <EM>services.xml</EM> file
has following information.</P>
<OL>
	<LI><P STYLE="margin-bottom: 0in">Service level parameters 
	</P>
	<LI><P STYLE="margin-bottom: 0in">Modules that are engaged Service
	level 
	</P>
	<LI><P>Operations inside the Service</P>
</OL>
<H3>Module Archive</H3>
<P>Module archive must have a <EM>META-INF/module.xml</EM> file and
dependent classes the <EM>module.xml</EM> file has Module parameters
and the Operations defined in the module.</P>
<P>When the system started up the Axis2 ask the deployment model to
create a Axis Configuration, the Deployment Model first find a
<EM>axis2.xml</EM> file and build the global configuration. Then the
Deployment check for the Module archives and then for the service
archives, the corresponding services and Modules are added to the
Axis Configuration. System will build Contexts on top of the Axis
Configurations and the Axis2 is ready to send or receive the SOAP
Message. The Hot deployment is allowed only for the Service and in
that case a thread will check the repository repeatedly, and add the
Service corresponds to the new found Service archives to the
repository. 
</P>
<H2><A NAME="bmWSDL"></A>WSDL and code generation</H2>
<P>Although the basic objective of the code generation tool has not
changed, the Code generation module of Axis2 has taken a different
approach to generate code. Primarily the change is in the use of
templates, namely XSL templates which gives the code generator the
flexibility to generate code in multiple languages. 
</P>
<P>The basic approach is to set the code generator to generate an XML
and parse it with a template to generate the code file. The following
figure shows how this shows up in the architecture of the tool.</P>
<P><IMG SRC="images/archi-guide/CodegenArchitecture.jpg" NAME="Graphic6" ALIGN=BOTTOM WIDTH=478 HEIGHT=218 BORDER=0></P>
<P>The fact here is that it is the same information that is extracted
from the WSDL no matter what code is generated. Code generator uses
the WOM (WSDL Object Model) internally to manipulate the WSDL and
passes that information to the emitter which emits an XML. the XML is
then parsed with the relevant XSL to generate the code. No matter
what the language, the process is the same except for the template
that is being used</P>
<H2><A NAME="bmDB"></A>Data Binding</H2>
<H3>Integration with the code generation engine</H3>
<P>Axis2 M2 was released with code generation support but without
data binding. The version 0.9 was shipped with data binding support
with complete schema support. Such claim is made possible because of
the fact that the data binding tool, xml-beans, has the full schema
support. The original architecture of the code generation framework
did not undergo significant changes because of the way that the code
generation framework was originally designed. Data binding was
incorporated as a pluggable extension to the code generation engine.
Version 0.91 did not does not support SOAP encoding. It only supports
RPC literal or document literal massages.</P>
<P><IMG SRC="images/codegen.gif" NAME="Graphic7" ALIGN=BOTTOM WIDTH=75 HEIGHT=38 BORDER=0></P>
<H3>Serialization and Dezerialization</H3>
<P>Xml-beans supports StAX API and AXIOM is based on a StAX API. Data
binding in Axis2 is achieved through interfacing the AXIOM with the
Xml-beans using the StAX API which is supported by both parties. At
the time of the code generation there will be supporter classes for
each WSDL operation that will have the utility methods that can
deserialize the from AXIOM to data bound object and serialize from
data bound object to AXIOM. For example if the WSDL has an operation
called &quot;echoString&quot;, once the code is generated there will
be an echoStringDatabindingSupporter.java class generated that will
have methods that will look like the following.</P>
<P>public static org.apache.axis2.om.OMElement
toOM(org.soapinterop.xsd.EchoStringParamDocument param) : This method
will handle the serialization.</P>
<P>public static org.apache.xmlbeans.XmlObject
fromOM(org.apache.axis2.om.OMElement param, java.lang.Class type) :
This method will handle the deserialization.</P>
<P>public static org.apache.xmlbeans.XmlObject
getTestObject(java.lang.Class type) : This will be a utility method
that can be used to create sample objects of the given data bound
object.</P>
<H2><A NAME="bmClientAPI"></A>Client API</H2>
<P>There are three parameters that decide the nature of the Web
Service interaction.</P>
<OL>
	<LI><P STYLE="margin-bottom: 0in">Message Exchange Pattern 
	</P>
	<LI><P STYLE="margin-bottom: 0in">The Behavior of the transport.
	Does it act one-way or two way 
	</P>
	<LI><P>Synchronous/ Asynchronous behavior of the Client API 
	</P>
</OL>
<P>Variations of the three parameters can result in indefinite number
of scenarios, even though Axis2 is built on a core that support any
messaging interaction, the developers were compelled to support only
two most widely used Message Exchange Patterns.</P>
<P>Two supported transports are One-Way and the Request-Response
scenarios in the Client API, the implementation is based on a class
called <CODE>MEPClient</CODE> and there are extensions for each
Message Exchange Pattern that Axis2 Client API supports.</P>
<H3>One Way Messaging Support</H3>
<P>The One-Way support is provided by the <CODE>InOnlyMEPClient</CODE>
and Axis2 provides a class called <CODE>Call</CODE> that provides a
much simpler interface for the user. The Axis2 supports HTTP/SMTP and
TCP transports, in the case of the HTTP transport the return channel
is not used and the HTTP 202 OK is returned in the return Channel. 
</P>
<H3>Request Response Messaging Support</H3>
<P>The Request-Response support is provided by the <CODE>InOutMEPClient</CODE>
and Axis2 provides a class called <CODE>MessageSender</CODE> that
provides a much simpler interface for the user. The Client API has
four ways to configure a given Message Exchange</P>
<OL>
	<LI><P STYLE="margin-bottom: 0in">Blocking or Non-Blocking nature -
	this can be decided by using <CODE>invokeBlocking()</CODE> or
	<CODE>invokeNonBlocking()</CODE> methods 
	</P>
	<LI><P STYLE="margin-bottom: 0in">Sender transport - transport use
	to send the SOAP Message 
	</P>
	<LI><P STYLE="margin-bottom: 0in">Listener transport - transport the
	Response is received 
	</P>
	<LI><P>Use Separate Channel - does the response is send over a
	separate transport connection or not, this can be false only when
	sender an listener transport is same and is a two way transport. 
	</P>
</OL>
<P>Depend on the values for the above four parameter, Axis2 behave
differently</P>
<H2><A NAME="bmTransports"></A>Transports</H2>
<P>Axis2 has two basic constructs for transports, named as Transport
In Configuration and Transport Out Configuration. The <A HREF="#messageContext">Message
Context</A> has two fields to put the input and the out put transport
to be used. Axis behaves according to the transport that is specified
in each of the fields. 
</P>
<P>SOAP Message is arrived at the Server side, the incoming transport
is decided by the Transport Listener that accepts the incoming SOAP
Message. The transports for the subsequent SOAP Messages that are
related to the first message, are decided based on the addressing
parameters.</P>
<P>At the Client Side the user is free to specify the transport to be
used, as in the Server side the transport for the subsequent SOAP
Messages are decided by the addressing.</P>
<P>There Transport In Configuration and the Transport Out
Configuration contains following information. 
</P>
<OL>
	<LI><P STYLE="margin-bottom: 0in">Transport Sender in Out
	Configuration, Transport Listener in the TransportIn Configuration 
	</P>
	<LI><P STYLE="margin-bottom: 0in">Parameters of the transport 
	</P>
	<LI><P>Transport Handlers 
	</P>
</OL>
<P>Transport Sender send the SOAP Message over a given transport,
each and every transport Out Configuration should define a transport
Sender that send the transport. 
</P>
<P>Transport Receiver waits for the SOAP Messages and for each SOAP
Message that arrives, uses the <I>In Pipe</I> to process the SOAP
Message.</P>
<P>Axis2 Presently support the following transports</P>
<OL>
	<LI><P STYLE="margin-bottom: 0in">HTTP - The HTTP transport, the
	transport Listener is a Servelet or a Simple HTTP server provided by
	Axis2. The transport Sender uses sockets to connect and send the
	SOAP Message. Currently we have the commons-HTTP-client based HTTP
	Transport sender as the default transport 
	</P>
	<LI><P STYLE="margin-bottom: 0in">TCP - This is the most simplest
	transport, but needed the addressing support to be functional. 
	</P>
	<LI><P>SMTP - This work off a single email account, Transport
	Receiver is a tread that checks for emails in fixed time intervals. 
	</P>
</OL>
</BODY>
</HTML>